#[derive(Clone, Debug, Eq, PartialEq)]
pub enum LexKeyword {
    Auto,
    Break,
    Case,
    Char,
    Const,
    Continue,
    Default,
    Do,
    Double,
    Else,
    Enum,
    Extern,
    Float,
    For,
    Goto,
    If,
    Inline,
    Int,
    Long,
    Register,
    Restrict,
    Return,
    Short,
    Signed,
    Sizeof,
    Static,
    Struct,
    Switch,
    Typedef,
    Union,
    Unsigned,
    Void,
    Volatile,
    While,
    Bool,
    Complex,
    Imaginary,
}

#[derive(Clone, Debug, PartialEq)]
pub enum NumberType {
    Float(f32),
    Double(f64),
    SignedChar(i8),
    UnsignedChar(u8),
    SignedShort(i16),
    UnsignedShort(u16),
    SignedInt(i32),
    UnsignedInt(u32),
    SignedLong(i64),
    UnsignedLong(u64),
    SignedLongLong(i128),
    UnsignedLongLong(u128),
}

impl Default for NumberType {
    fn default() -> Self {
        NumberType::UnsignedChar(0)
    }
}

pub const LITERAL_TOKENS: &[(&str, LexItem)] = &[
    ("=", LexItem::Assign),
    ("+=", LexItem::AddAssign),
    ("-=", LexItem::SubAssign),
    ("*=", LexItem::MulAssign),
    ("/=", LexItem::DivAssign),
    ("%=", LexItem::ModAssign),
    ("<<=", LexItem::LShiftAssign),
    (">>=", LexItem::RShiftAssign),
    ("&=", LexItem::AndAssign),
    ("|=", LexItem::OrAssign),
    ("^=", LexItem::XorAssign),
    ("!=", LexItem::NotEqual),
    (">=", LexItem::GreaterOrEqual),
    (">", LexItem::GreaterThan),
    ("+", LexItem::Plus),
    ("-", LexItem::Minus),
    ("*", LexItem::Mul),
    ("/", LexItem::Div),
    ("%", LexItem::Mod),
    ("<<", LexItem::LShift),
    (">>", LexItem::RShift),
    ("~", LexItem::Not),
    ("^", LexItem::Xor),
    ("|", LexItem::Or),
    ("&", LexItem::And),
    ("!", LexItem::LogicalNot),
    ("||", LexItem::LogicalOr),
    ("&&", LexItem::LogicalAnd),
    ("==", LexItem::Equals),
    ("!=", LexItem::NotEqual),
    ("<", LexItem::LessThan),
    (">", LexItem::GreaterThan),
    ("<=", LexItem::LessOrEqual),
    (">=", LexItem::GreaterOrEqual),
    ("++", LexItem::Increment),
    ("--", LexItem::Decrement),
    ("(", LexItem::LeftParen),
    (")", LexItem::RightParen),
    ("[", LexItem::LeftBracket),
    ("]", LexItem::RightBracket),
    ("{", LexItem::LeftCurlyBrace),
    ("}", LexItem::RightCurlyBrace),
    ("->", LexItem::PointerDeref),
    (";", LexItem::Semicolon),
    (":", LexItem::Colon),
    (",", LexItem::Comma),
    (".", LexItem::Period),
    ("?", LexItem::Question),
    ("auto\x00", LexItem::Keyword(LexKeyword::Auto)),
    ("break\x00", LexItem::Keyword(LexKeyword::Break)),
    ("case\x00", LexItem::Keyword(LexKeyword::Case)),
    ("char\x00", LexItem::Keyword(LexKeyword::Char)),
    ("const\x00", LexItem::Keyword(LexKeyword::Const)),
    ("continue\x00", LexItem::Keyword(LexKeyword::Continue)),
    ("default\x00", LexItem::Keyword(LexKeyword::Default)),
    ("do\x00", LexItem::Keyword(LexKeyword::Do)),
    ("double\x00", LexItem::Keyword(LexKeyword::Double)),
    ("else\x00", LexItem::Keyword(LexKeyword::Else)),
    ("enum\x00", LexItem::Keyword(LexKeyword::Enum)),
    ("extern\x00", LexItem::Keyword(LexKeyword::Extern)),
    ("float\x00", LexItem::Keyword(LexKeyword::Float)),
    ("for\x00", LexItem::Keyword(LexKeyword::For)),
    ("goto\x00", LexItem::Keyword(LexKeyword::Goto)),
    ("if\x00", LexItem::Keyword(LexKeyword::If)),
    ("inline\x00", LexItem::Keyword(LexKeyword::Inline)),
    ("int\x00", LexItem::Keyword(LexKeyword::Int)),
    ("long\x00", LexItem::Keyword(LexKeyword::Long)),
    ("register\x00", LexItem::Keyword(LexKeyword::Register)),
    ("restrict\x00", LexItem::Keyword(LexKeyword::Restrict)),
    ("return\x00", LexItem::Keyword(LexKeyword::Return)),
    ("short\x00", LexItem::Keyword(LexKeyword::Short)),
    ("signed\x00", LexItem::Keyword(LexKeyword::Signed)),
    ("sizeof\x00", LexItem::Keyword(LexKeyword::Sizeof)),
    ("static\x00", LexItem::Keyword(LexKeyword::Static)),
    ("struct\x00", LexItem::Keyword(LexKeyword::Struct)),
    ("switch\x00", LexItem::Keyword(LexKeyword::Switch)),
    ("typedef\x00", LexItem::Keyword(LexKeyword::Typedef)),
    ("union\x00", LexItem::Keyword(LexKeyword::Union)),
    ("unsigned\x00", LexItem::Keyword(LexKeyword::Unsigned)),
    ("void\x00", LexItem::Keyword(LexKeyword::Void)),
    ("volatile\x00", LexItem::Keyword(LexKeyword::Volatile)),
    ("while\x00", LexItem::Keyword(LexKeyword::While)),
    ("_Bool\x00", LexItem::Keyword(LexKeyword::Bool)),
    ("_Complex\x00", LexItem::Keyword(LexKeyword::Complex)),
    ("_Imaginary\x00", LexItem::Keyword(LexKeyword::Imaginary)),
];

#[derive(Clone, Debug, PartialEq)]
pub enum LexItem {
    // Literals
    StringLiteral(Vec<u8>),
    NumericLiteral(NumberType),

    Identifier(String),
    Keyword(LexKeyword),

    // Operations
    Plus,
    // Not necessarily a binomial operation
    Minus,
    // Not necessarily a binomial operation
    Mul,
    Div,
    Mod,
    LShift,
    RShift,
    Not,
    Xor,
    Or,
    And,
    LogicalNot,
    LogicalOr,
    LogicalAnd,
    Equals,
    NotEqual,
    LessThan,
    GreaterThan,
    LessOrEqual,
    GreaterOrEqual,
    Increment,
    Decrement,

    AddAssign,
    SubAssign,
    MulAssign,
    DivAssign,
    ModAssign,
    LShiftAssign,
    RShiftAssign,
    AndAssign,
    OrAssign,
    XorAssign,
    Assign,

    // Brackets
    LeftParen,
    RightParen,
    LeftBracket,
    RightBracket,
    LeftCurlyBrace,
    RightCurlyBrace,

    // Other Syntax
    PointerDeref,
    Semicolon,
    Colon,
    Comma,
    Period,
    Question,
}
