#[derive(Clone, Debug, PartialEq)]
pub enum NumberType {
    #[allow(dead_code)]
    Float(f32),
    #[allow(dead_code)]
    Double(f64),
    SignedChar(i8),
    UnsignedChar(u8),
    SignedShort(i16),
    UnsignedShort(u16),
    SignedInt(i32),
    UnsignedInt(u32),
    SignedLong(i64),
    UnsignedLong(u64),
    SignedLongLong(i128),
    UnsignedLongLong(u128),
}

impl Default for NumberType {
    fn default() -> Self {
        NumberType::UnsignedChar(0)
    }
}

pub const LITERAL_TOKENS: &[(&str, LexItem)] = &[
    ("=", LexItem::Assign),
    ("+=", LexItem::AddAssign),
    ("-=", LexItem::SubAssign),
    ("*=", LexItem::MulAssign),
    ("/=", LexItem::DivAssign),
    ("%=", LexItem::ModAssign),
    ("<<=", LexItem::LShiftAssign),
    (">>=", LexItem::RShiftAssign),
    ("&=", LexItem::AndAssign),
    ("|=", LexItem::OrAssign),
    ("^=", LexItem::XorAssign),
    ("!=", LexItem::NotEqual),
    (">=", LexItem::GreaterOrEqual),
    (">", LexItem::GreaterThan),
    ("+", LexItem::Plus),
    ("-", LexItem::Minus),
    ("*", LexItem::Mul),
    ("/", LexItem::Div),
    ("%", LexItem::Mod),
    ("<<", LexItem::LShift),
    (">>", LexItem::RShift),
    ("~", LexItem::Not),
    ("^", LexItem::Xor),
    ("|", LexItem::Or),
    ("&", LexItem::And),
    ("!", LexItem::LogicalNot),
    ("||", LexItem::LogicalOr),
    ("&&", LexItem::LogicalAnd),
    ("==", LexItem::Equals),
    ("!=", LexItem::NotEqual),
    ("<", LexItem::LessThan),
    (">", LexItem::GreaterThan),
    ("<=", LexItem::LessOrEqual),
    (">=", LexItem::GreaterOrEqual),
    ("++", LexItem::Increment),
    ("--", LexItem::Decrement),
    ("(", LexItem::LeftParen),
    (")", LexItem::RightParen),
    ("[", LexItem::LeftBracket),
    ("]", LexItem::RightBracket),
    ("{", LexItem::LeftCurlyBrace),
    ("}", LexItem::RightCurlyBrace),
    ("->", LexItem::PointerDeref),
    (";", LexItem::Semicolon),
    (":", LexItem::Colon),
    (",", LexItem::Comma),
    (".", LexItem::Period),
    ("?", LexItem::Question),
    ("auto\x00", LexItem::Auto),
    ("break\x00", LexItem::Break),
    ("case\x00", LexItem::Case),
    ("char\x00", LexItem::Char),
    ("const\x00", LexItem::Const),
    ("continue\x00", LexItem::Continue),
    ("default\x00", LexItem::Default),
    ("do\x00", LexItem::Do),
    ("double\x00", LexItem::Double),
    ("else\x00", LexItem::Else),
    ("enum\x00", LexItem::Enum),
    ("extern\x00", LexItem::Extern),
    ("float\x00", LexItem::Float),
    ("for\x00", LexItem::For),
    ("goto\x00", LexItem::Goto),
    ("if\x00", LexItem::If),
    ("inline\x00", LexItem::Inline),
    ("int\x00", LexItem::Int),
    ("long\x00", LexItem::Long),
    ("register\x00", LexItem::Register),
    ("restrict\x00", LexItem::Restrict),
    ("return\x00", LexItem::Return),
    ("short\x00", LexItem::Short),
    ("signed\x00", LexItem::Signed),
    ("sizeof\x00", LexItem::Sizeof),
    ("static\x00", LexItem::Static),
    ("struct\x00", LexItem::Struct),
    ("switch\x00", LexItem::Switch),
    ("typedef\x00", LexItem::Typedef),
    ("union\x00", LexItem::Union),
    ("unsigned\x00", LexItem::Unsigned),
    ("void\x00", LexItem::Void),
    ("volatile\x00", LexItem::Volatile),
    ("while\x00", LexItem::While),
    ("_Bool\x00", LexItem::Bool),
    ("_Complex\x00", LexItem::Complex),
    ("_Imaginary\x00", LexItem::Imaginary),
];

#[derive(Clone, Debug, PartialEq)]
pub enum LexItem {
    // Literals
    StringLiteral(Vec<u8>),
    NumericLiteral(NumberType),

    Identifier(String),

    // Operations
    Plus,
    // Not necessarily a binomial operation
    Minus,
    // Not necessarily a binomial operation
    Mul,
    Div,
    Mod,
    LShift,
    RShift,
    Not,
    Xor,
    Or,
    And,
    LogicalNot,
    LogicalOr,
    LogicalAnd,
    Equals,
    NotEqual,
    LessThan,
    GreaterThan,
    LessOrEqual,
    GreaterOrEqual,
    Increment,
    Decrement,

    AddAssign,
    SubAssign,
    MulAssign,
    DivAssign,
    ModAssign,
    LShiftAssign,
    RShiftAssign,
    AndAssign,
    OrAssign,
    XorAssign,
    Assign,

    // Brackets
    LeftParen,
    RightParen,
    LeftBracket,
    RightBracket,
    LeftCurlyBrace,
    RightCurlyBrace,

    // Other Syntax
    PointerDeref,
    Semicolon,
    Colon,
    Comma,
    Period,
    Question,

    // Keywords
    Auto,
    Break,
    Case,
    Char,
    Const,
    Continue,
    Default,
    Do,
    Double,
    Else,
    Enum,
    Extern,
    Float,
    For,
    Goto,
    If,
    Inline,
    Int,
    Long,
    Register,
    Restrict,
    Return,
    Short,
    Signed,
    Sizeof,
    Static,
    Struct,
    Switch,
    Typedef,
    Union,
    Unsigned,
    Void,
    Volatile,
    While,
    Bool,
    Complex,
    Imaginary,
}
